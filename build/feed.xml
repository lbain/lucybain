<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucy Bain</title>
  <id>http://lucybain.com/blog</id>
  <link href="http://lucybain.com/blog"/>
  <link href="http://lucybain.com/feed.xml" rel="self"/>
  <updated>2014-12-04T00:00:00Z</updated>
  <author>
    <name>Lucy Bain</name>
  </author>
  <entry>
    <title>JS: feature detection vs. inference vs. UA string</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/feature-detection-vs-inference/"/>
    <id>http://lucybain.com/blog/2014/feature-detection-vs-inference/</id>
    <published>2014-12-04T00:00:00Z</published>
    <updated>2014-12-08T22:16:33+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s the difference between feature detection, feature inference, and using the UA string?&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s start smaller...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is feature detection?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When you check if a certain feature exists, that&amp;#39;s feature detection.&lt;/p&gt;

&lt;p&gt;We need to write code that checks if features exist in JS since different browsers have different implementations, something like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var text;
if(typeof(Text) === "function"){
    text = new Text('Oh, how quick that fox was!');
} else {
    text = 'Oh, how quick that fox was!';
}
&lt;/pre&gt;
&lt;p&gt;That means you can be confident you&amp;#39;ve covered all of your bases with different browser implementations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is feature inference?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When you make an assumption that because one feature is present (or not) another one will also be present (or not). (And you know what people say about when you assume something...)&lt;/p&gt;

&lt;p&gt;The general thought process goes like this:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Chrome implements the &lt;code&gt;Text&lt;/code&gt; function. I also know Chrome doesn&amp;#39;t have &lt;code&gt;applyElement&lt;/code&gt; like IE does. So I&amp;#39;ll write code like...&lt;/em&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;if(typeof applyElement != 'undefined') {
    // now I know I'm not in IE, I'll just assume Text is available
    text = new Text('Oh, how quick that fox was!');
}
&lt;/pre&gt;
&lt;p&gt;But oops! Someone looked at that code in Firefox which doesn&amp;#39;t implement &lt;code&gt;applyElement&lt;/code&gt; or &lt;code&gt;Text&lt;/code&gt;! They got an error :(&lt;/p&gt;

&lt;p&gt;So that&amp;#39;s the problem. Since you&amp;#39;re not checking for the feature you&amp;#39;re using you&amp;#39;re more likely to have inconsistencies. Also, if in the future one of the browsers changes what they implement all your assumptions will be inacurate.&lt;/p&gt;

&lt;p&gt;So yeah, it&amp;#39;s bad.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is the UA string?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;quot;UA&amp;quot; stands for user agent, which means the browser (and a whole lot of other stuff). Mine looks like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71
&lt;/pre&gt;
&lt;p&gt;(You can find your user string at &lt;a href="http://whatsmyuseragent.com/"&gt;whatsmyuseragent.com&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;But you can see in there (at the end) it says what browser I&amp;#39;m on. So it would be possible to check for a specific version of Chrome by &amp;quot;sniffing&amp;quot; the user agent string. This is generally considered bad practice (but seems to be slightly better practice than feature inference).&lt;/p&gt;

&lt;p&gt;Just like with feature inference, if you use the UA string you&amp;#39;re making an assumption about how the string will be written, what changes are likely to happen in this particular version, and that your code will be able to handle any future changes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Use feature detection if you&amp;#39;re working with a feature that isn&amp;#39;t available across all browsers. When the browsers upgrade your code will be able to take advantage of the upgrade and your code will still work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.nczonline.net/blog/2009/12/29/feature-detection-is-not-browser-detection/"&gt;Feature detection is not browser detection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/a/20105161/863846"&gt;Stack overflow answer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mozilla&amp;#39;s article on &lt;a href="https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent"&gt;working with the user agent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: &lt;code&gt;.call&lt;/code&gt; vs. &lt;code&gt;.apply&lt;/code&gt;</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/call-vs-apply/"/>
    <id>http://lucybain.com/blog/2014/call-vs-apply/</id>
    <published>2014-11-30T00:00:00Z</published>
    <updated>2014-11-30T15:55:37+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s the difference between &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt;?&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s start with the similarities.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Both methods allow you to invoke a function and pass parameters through.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function printer(message) {
    console.log(message)
}

printer.call("hello") // logs "hello"
printer.apply("world!") // logs "world!"
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Wow. Awesome. A more verbose way to invoke functions. Fantastic. Why not just use &lt;code&gt;printer(&amp;quot;hello&amp;quot;)&lt;/code&gt;?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Well actually, &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt; can do more than simply invoke a method, they can also pass through &lt;strong&gt;context&lt;/strong&gt;. Here&amp;#39;s an example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function Person(name){
    this.name = name;
    this.introduceSelf = function() {
        console.log("Hello, my name is " + this.name);
    }
}

var alice = new Person('Alice');
alice.introduceSelf();
// logs "Hello, my name is Alice", as expected

alice.introduceSelf.call({name: "Bob"});
// logs "Hello, my name is Bob"

alice.introduceSelf.apply({name: "Casey"});
// logs "Hello, my name is Casey"
&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt; allow you to manipulate the &lt;code&gt;this&lt;/code&gt; keyword for the invoked function.&lt;/p&gt;

&lt;p&gt;On to the main question...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What&amp;#39;s the difference between &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It&amp;#39;s all about the way you pass parameters. That&amp;#39;s it. Let&amp;#39;s make our previous example more complex:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function Person(name){
    this.name = name;
    this.introduceSelf = function(greeting) {
        console.log(greeting + ", my name is " + this.name);
    }
}

var alice = new Person('Alice');
alice.introduceSelf('Hello');
// logs "Hello, my name is Alice", as expected

alice.introduceSelf.call({name: "Bob"}, 'Bonjour');
// logs "Bonjour, my name is Bob"

alice.introduceSelf.apply({name: "Casey"}, ['Hola']);
// logs "Hola, my name is Casey"
&lt;/pre&gt;
&lt;p&gt;For &lt;code&gt;.call&lt;/code&gt; you pass the parameters comma separated (like normal). For &lt;code&gt;.apply&lt;/code&gt; you pass the parameters in an array.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Why would you even bother having these two ways? Why not standardise?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;That&amp;#39;s a fair question. But the two methods have different use cases. If you know exactly how many arguments you&amp;#39;re passing, you should use &lt;code&gt;.call&lt;/code&gt;. If you don&amp;#39;t know, or if your arguments are already in an array, you should use &lt;code&gt;.apply&lt;/code&gt;. (Rephrased from a helpful &lt;a href="http://stackoverflow.com/a/1987244/863846"&gt;stackoverflow answer&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ok, how am I going to remember this?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Turns out the folks on stackoverflow have some thoughts on that one too. Here&amp;#39;s how I&amp;#39;ll be remembering it:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;a&lt;/strong&gt;pply uses &lt;strong&gt;a&lt;/strong&gt;n &lt;strong&gt;a&lt;/strong&gt;rray&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c&lt;/strong&gt;all &lt;strong&gt;c&lt;/strong&gt;ounts with &lt;strong&gt;c&lt;/strong&gt;ommas&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply"&gt;stackoverflow question&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx"&gt;Scott Allen&amp;#39;s post&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: ways to create objects</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/ways-to-create-objects/"/>
    <id>http://lucybain.com/blog/2014/ways-to-create-objects/</id>
    <published>2014-11-26T00:00:00Z</published>
    <updated>2014-11-26T22:11:30+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What are a few different ways to create new objects?&lt;/h2&gt;

&lt;p&gt;Well it turns out this topic has been covered quite a lot (unlike my last post about host vs. native objects). I don&amp;#39;t really have anything to add to the conversation, so I&amp;#39;ll just give you the two links that I found the most helpful on this topic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.phpied.com/3-ways-to-define-a-javascript-class/"&gt;phpied&lt;/a&gt; - an attractive explanation. I found this easiest to read.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://a-developer-life.blogspot.com.au/2011/11/7-ways-to-create-objects-in-javascript.html"&gt;A Developer Life&lt;/a&gt; - an exhaustive list of ways to create objects, complete with examples. This was more in depth.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I hope you find those sites as useful as I did!&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>JS: host vs. native objects</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/host-vs-native/"/>
    <id>http://lucybain.com/blog/2014/host-vs-native/</id>
    <published>2014-11-16T00:00:00Z</published>
    <updated>2014-11-26T21:19:31+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s the difference between host objects and native objects?&lt;/h2&gt;

&lt;p&gt;I didn&amp;#39;t find as much lot of information about this topic as some of the other &lt;a href="https://github.com/darcyclarke/Front-end-Developer-Interview-Questions#js"&gt;JS interview questions&lt;/a&gt;. So here&amp;#39;s my current understanding, but please comment if I&amp;#39;ve misunderstood or there&amp;#39;s a better way to explain it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is a native object?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Native objects are inherent to JS - they are available to you so long as you&amp;#39;re using JS. You can be in the browser or in Node, but if you&amp;#39;re writing JS, you&amp;#39;ve got access to the native objects. Here&amp;#39;s a &lt;a href="http://es5.github.io/#x8"&gt;list&lt;/a&gt; of them if you want to know what&amp;#39;s available to you.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is a host object?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Everything the environment gives you. For the browser, this includes objects like &lt;code&gt;window&lt;/code&gt;. Host objects can differ by environment (or host), so that Node wouldn&amp;#39;t have access to &lt;code&gt;window&lt;/code&gt; (which makes sense since there&amp;#39;s no DOM for Node), but could have it&amp;#39;s own host objects like &lt;code&gt;NodeLists&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is a user object?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is where I got the most confused. The question asks for the difference between &lt;strong&gt;host&lt;/strong&gt; and &lt;strong&gt;native&lt;/strong&gt; objects, which was covered on a few sites. However, a couple of sites make a third category: &lt;strong&gt;user&lt;/strong&gt; objects. There seems to be some debate about user objects being their own category. I&amp;#39;m not sure which side is right so I&amp;#39;m adding a little blurb about them here, but please ignore if it&amp;#39;s not relevant.&lt;/p&gt;

&lt;p&gt;User objects are anything the user defines. When you create a new object that is not directly a native object, you&amp;#39;ve made a user object. So if you create a new string (&lt;code&gt;&amp;quot;Hello world&amp;quot;&lt;/code&gt;) you created a native object, but if you create an instance of an object you&amp;#39;ve defined (&lt;code&gt;&amp;quot;new Cat()&amp;quot;&lt;/code&gt;) then it&amp;#39;s a user object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/7614317/what-is-the-difference-between-native-objects-and-host-objects"&gt;stackoverflow questionn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://programmerinnervoice.wordpress.com/2013/07/22/host-objects-vs-native-objects/"&gt;Programmer Inner Voice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sitepoint.com/oriented-programming-1-4/"&gt;Sitepoint&lt;/a&gt; which also mentioned user object as a separate category, although it was posted way back in 2001&lt;/li&gt;
&lt;li&gt;and &lt;a href="http://perfectionkills.com/extending-native-builtins/"&gt;Perfection Kills&lt;/a&gt;, although this one was less on topic&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: anonymous functions</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/anonymous-functions/"/>
    <id>http://lucybain.com/blog/2014/anonymous-functions/</id>
    <published>2014-11-02T00:00:00Z</published>
    <updated>2014-11-25T21:30:14+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s a typical use case for anonymous functions?&lt;/h2&gt;

&lt;p&gt;I&amp;#39;m going to go with my high school training and focus on the word &lt;strong&gt;typical&lt;/strong&gt;. So long as we&amp;#39;re just talking about typical use, here&amp;#39;s my answer:&lt;/p&gt;

&lt;p&gt;Anonymous functions are typically used as callbacks.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So what&amp;#39;s a callback?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I&amp;#39;m glad you asked!&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function takesACallback(callback) {
    // do some interesting things here
    return "The callback says: " + callback();
}

takesACallback(function() {
    return "I'm the callback!";
}); // returns "The callback says: I'm the callback!"
&lt;/pre&gt;
&lt;p&gt;See the function that&amp;#39;s a parameter to the &lt;code&gt;takesACallback&lt;/code&gt; call? Notice that it doesn&amp;#39;t have a name? That&amp;#39;s an anonymous function.&lt;/p&gt;

&lt;p&gt;Note that you can still have a reference to an anonymous function, just because it is unnamed it doesn&amp;#39;t mean it&amp;#39;s unreferenced.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var reference = function() {
    return "I'm still an anonymous function";
}

reference(); // returns "I'm still an anonymous function"
&lt;/pre&gt;
&lt;p&gt;This is almost the same as&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function reference() {
    return "I'm not anonymous function";
}

reference(); // returns "I'm not anonymous function"
&lt;/pre&gt;
&lt;p&gt;A named function is called a function declaration.&lt;/p&gt;

&lt;p&gt;According to &lt;a href="http://helephant.com/2008/08/23/javascript-anonymous-functions/"&gt;Helen&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Anonymous functions are created at runtime ... Function declarations are different. They are run before any of the other code is executed so the functions do not have to be declared before the code that calls them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So you can see there&amp;#39;s a difference to how the two &lt;code&gt;reference&lt;/code&gt; example functions are treated by JS, even if the code looks very similar.&lt;/p&gt;

&lt;p&gt;You can find a list of pros and cons on &lt;a href="http://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo"&gt;stackoverflow&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>JS: what is a closure?</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/closures/"/>
    <id>http://lucybain.com/blog/2014/closures/</id>
    <published>2014-10-18T00:00:00Z</published>
    <updated>2014-11-25T19:29:08+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What is a closure, and how/why would you use one?&lt;/h2&gt;

&lt;p&gt;A closure is a way of keeping access to variables in a function after that function has returned.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fantastic, now again, not as a dictionary.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Usually you lose access to variables when a function returns:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function notAClosure() {
    var shortLivedVariable = "I'm only here for a little while";
    return shortLivedVariable;
}
notAClosure(); // returns "I'm only here for a little while"
&lt;/pre&gt;
&lt;p&gt;Notice that nothing has access to &lt;code&gt;shortLivedVariable&lt;/code&gt; now that &lt;code&gt;notAClosure&lt;/code&gt; has run. Sure, you can call &lt;code&gt;notAClosure&lt;/code&gt; again (and again and again), but each call will create a whole new &lt;code&gt;shortLivedVariable&lt;/code&gt;. But hey, it&amp;#39;s hard to tell that each &lt;code&gt;shortLivedVariable&lt;/code&gt; is brand new, so let&amp;#39;s clear that up a bit.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function stillNotAClosure(anotherShortLivedVariable) {
    return anotherShortLivedVariable;
}
stillNotAClosure("brand"); // returns "brand"
stillNotAClosure("new"); // returns "new"
stillNotAClosure("string"); // returns "string"
&lt;/pre&gt;
&lt;p&gt;Thus, you can see &lt;code&gt;stillNotAClosure&lt;/code&gt; doesn&amp;#39;t retain any reference to previous calls.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ok, so that&amp;#39;s what a closure isn&amp;#39;t, but what &lt;strong&gt;is&lt;/strong&gt; a closure?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In a closure those variables stick around for a while longer since there is a reference to the variables after the function returns.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function aClosure() {
    var longLivedVariable = "I'm here for a long time";
    var innerFunction = function inner() {
        return longLivedVariable;
    }
    return innerFunction;
}
var closure = aClosure(); // returns a reference to innerFunction
closure(); // returns "I'm here for a long time"
&lt;/pre&gt;
&lt;p&gt;Notice that &lt;code&gt;aClosure&lt;/code&gt; doesn&amp;#39;t return &lt;code&gt;longLivedVariable&lt;/code&gt;, but rather &lt;code&gt;innerFunction&lt;/code&gt;. This means there&amp;#39;s a reference hanging around to &lt;code&gt;innerFunction&lt;/code&gt;, and because &lt;code&gt;innerFunction&lt;/code&gt; has a reference to &lt;code&gt;longLivedVariable&lt;/code&gt;, that variable continues to exist.&lt;/p&gt;

&lt;p&gt;Finally, when we call &lt;code&gt;closure()&lt;/code&gt;, we&amp;#39;re really calling &lt;code&gt;innerFunction()&lt;/code&gt; (the returned value of &lt;code&gt;aClosure()&lt;/code&gt;), which in turn returns &lt;code&gt;longLivedVariable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Prove it, call the closure multiple times.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You got it.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function stillAClosure(anotherLongLivedVariable) {
    var innerFunction = function inner() {
        return anotherLongLivedVariable;
    }
    return innerFunction;
}
var closure = stillAClosure("The same string");
closure(); // returns "The same string"
closure(); // returns "The same string"
closure(); // returns "The same string"
&lt;/pre&gt;
&lt;p&gt;And here&amp;#39;s even more proof:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var closure1 = stillAClosure("String 1");
closure1(); // returns "String 1"
closure1(); // returns "String 1"

var closure2 = stillAClosure("String 2");
closure2(); // returns "String 2"
closure2(); // returns "String 2"

// And here's the kicker
closure1(); // returns "String 1"
&lt;/pre&gt;
&lt;p&gt;Bam! Did you see that! &lt;code&gt;closure1&lt;/code&gt; kept a reference to &lt;code&gt;&amp;quot;String 1&amp;quot;&lt;/code&gt; even though &lt;code&gt;stillAClosure&lt;/code&gt; had been called with a whole other parameter (namely &lt;code&gt;&amp;quot;String 2&amp;quot;&lt;/code&gt;). That&amp;#39;s some pretty cool stuff!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;OK, I&amp;#39;m convinced. But now &lt;strong&gt;why&lt;/strong&gt; would I ever want to use a closure?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Well, since closures keep access to the variables they can be used to save state. And things that save state look a whole lot like objects. (Before I get any haters, I know you can use closures for a bunch of other things, but this is a reasonable example.)&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function cat(name) {
    return {
        sayName: function() {
            return name;
        }
    }
}

var fluffy = cat('Mr. Fluffy');
fluffy.name // returns undefined
fluffy.sayName() // returns 'Mr. Fluffy'

var whiskers = cat('Whiskers');
whiskers.sayName() // returns 'Whiskers'
&lt;/pre&gt;
&lt;p&gt;So this way you can create a whole bunch of &lt;code&gt;cat&lt;/code&gt; objects that have a private &lt;code&gt;name&lt;/code&gt; variable, which you can access via the &lt;code&gt;sayName&lt;/code&gt; method.&lt;/p&gt;
</content>
  </entry>
</feed>
