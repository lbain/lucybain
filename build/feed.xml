<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucy Bain</title>
  <id>http://lucybain.com/blog</id>
  <link href="http://lucybain.com/blog"/>
  <link href="http://lucybain.com/feed.xml" rel="self"/>
  <updated>2014-11-16T00:00:00Z</updated>
  <author>
    <name>Lucy Bain</name>
  </author>
  <entry>
    <title>JS: host vs. native objects</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/host-vs-native/"/>
    <id>http://lucybain.com/blog/2014/host-vs-native/</id>
    <published>2014-11-16T00:00:00Z</published>
    <updated>2014-11-26T21:19:31+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s the difference between host objects and native objects?&lt;/h2&gt;

&lt;p&gt;I didn&amp;#39;t find as much lot of information about this topic as some of the other &lt;a href="https://github.com/darcyclarke/Front-end-Developer-Interview-Questions#js"&gt;JS interview questions&lt;/a&gt;. So here&amp;#39;s my current understanding, but please comment if I&amp;#39;ve misunderstood or there&amp;#39;s a better way to explain it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is a native object?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Native objects are inherent to JS - they are available to you so long as you&amp;#39;re using JS. You can be in the browser or in Node, but if you&amp;#39;re writing JS, you&amp;#39;ve got access to the native objects. Here&amp;#39;s a &lt;a href="http://es5.github.io/#x8"&gt;list&lt;/a&gt; of them if you want to know what&amp;#39;s available to you.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is a host object?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Everything the environment gives you. For the browser, this includes objects like &lt;code&gt;window&lt;/code&gt;. Host objects can differ by environment (or host), so that Node wouldn&amp;#39;t have access to &lt;code&gt;window&lt;/code&gt; (which makes sense since there&amp;#39;s no DOM for Node), but could have it&amp;#39;s own host objects like &lt;code&gt;NodeLists&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is a user object?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;This is where I got the most confused. The question asks for the difference between &lt;strong&gt;host&lt;/strong&gt; and &lt;strong&gt;native&lt;/strong&gt; objects, which was covered on a few sites. However, a couple of sites make a third category: &lt;strong&gt;user&lt;/strong&gt; objects. There seems to be some debate about user objects being their own category. I&amp;#39;m not sure which side is right so I&amp;#39;m adding a little blurb about them here, but please ignore if it&amp;#39;s not relevant.&lt;/p&gt;

&lt;p&gt;User objects are anything the user defines. When you create a new object that is not directly a native object, you&amp;#39;ve made a user object. So if you create a new string (&lt;code&gt;&amp;quot;Hello world&amp;quot;&lt;/code&gt;) you created a native object, but if you create an instance of an object you&amp;#39;ve defined (&lt;code&gt;&amp;quot;new Cat()&amp;quot;&lt;/code&gt;) then it&amp;#39;s a user object.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/7614317/what-is-the-difference-between-native-objects-and-host-objects"&gt;stackoverflow questionn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://programmerinnervoice.wordpress.com/2013/07/22/host-objects-vs-native-objects/"&gt;Programmer Inner Voice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.sitepoint.com/oriented-programming-1-4/"&gt;Sitepoint&lt;/a&gt; which also mentioned user object as a separate category, although it was posted way back in 2001&lt;/li&gt;
&lt;li&gt;and &lt;a href="http://perfectionkills.com/extending-native-builtins/"&gt;Perfection Kills&lt;/a&gt;, although this one was less on topic&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: anonymous functions</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/anonymous-functions/"/>
    <id>http://lucybain.com/blog/2014/anonymous-functions/</id>
    <published>2014-11-02T00:00:00Z</published>
    <updated>2014-11-25T21:30:14+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s a typical use case for anonymous functions?&lt;/h2&gt;

&lt;p&gt;I&amp;#39;m going to go with my high school training and focus on the word &lt;strong&gt;typical&lt;/strong&gt;. So long as we&amp;#39;re just talking about typical use, here&amp;#39;s my answer:&lt;/p&gt;

&lt;p&gt;Anonymous functions are typically used as callbacks.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;So what&amp;#39;s a callback?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I&amp;#39;m glad you asked!&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function takesACallback(callback) {
    // do some interesting things here
    return "The callback says: " + callback();
}

takesACallback(function() {
    return "I'm the callback!";
}); // returns "The callback says: I'm the callback!"
&lt;/pre&gt;
&lt;p&gt;See the function that&amp;#39;s a parameter to the &lt;code&gt;takesACallback&lt;/code&gt; call? Notice that it doesn&amp;#39;t have a name? That&amp;#39;s an anonymous function.&lt;/p&gt;

&lt;p&gt;Note that you can still have a reference to an anonymous function, just because it is unnamed it doesn&amp;#39;t mean it&amp;#39;s unreferenced.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var reference = function() {
    return "I'm still an anonymous function";
}

reference(); // returns "I'm still an anonymous function"
&lt;/pre&gt;
&lt;p&gt;This is almost the same as&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function reference() {
    return "I'm not anonymous function";
}

reference(); // returns "I'm not anonymous function"
&lt;/pre&gt;
&lt;p&gt;A named function is called a function declaration.&lt;/p&gt;

&lt;p&gt;According to &lt;a href="http://helephant.com/2008/08/23/javascript-anonymous-functions/"&gt;Helen&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Anonymous functions are created at runtime ... Function declarations are different. They are run before any of the other code is executed so the functions do not have to be declared before the code that calls them.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So you can see there&amp;#39;s a difference to how the two &lt;code&gt;reference&lt;/code&gt; example functions are treated by JS, even if the code looks very similar.&lt;/p&gt;

&lt;p&gt;You can find a list of pros and cons on &lt;a href="http://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo"&gt;stackoverflow&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>JS: what is a closure?</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/closures/"/>
    <id>http://lucybain.com/blog/2014/closures/</id>
    <published>2014-10-18T00:00:00Z</published>
    <updated>2014-11-25T19:29:08+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What is a closure, and how/why would you use one?&lt;/h2&gt;

&lt;p&gt;A closure is a way of keeping access to variables in a function after that function has returned.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fantastic, now again, not as a dictionary.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Usually you lose access to variables when a function returns:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function notAClosure() {
    var shortLivedVariable = "I'm only here for a little while";
    return shortLivedVariable;
}
notAClosure(); // returns "I'm only here for a little while"
&lt;/pre&gt;
&lt;p&gt;Notice that nothing has access to &lt;code&gt;shortLivedVariable&lt;/code&gt; now that &lt;code&gt;notAClosure&lt;/code&gt; has run. Sure, you can call &lt;code&gt;notAClosure&lt;/code&gt; again (and again and again), but each call will create a whole new &lt;code&gt;shortLivedVariable&lt;/code&gt;. But hey, it&amp;#39;s hard to tell that each &lt;code&gt;shortLivedVariable&lt;/code&gt; is brand new, so let&amp;#39;s clear that up a bit.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function stillNotAClosure(anotherShortLivedVariable) {
    return anotherShortLivedVariable;
}
stillNotAClosure("brand"); // returns "brand"
stillNotAClosure("new"); // returns "new"
stillNotAClosure("string"); // returns "string"
&lt;/pre&gt;
&lt;p&gt;Thus, you can see &lt;code&gt;stillNotAClosure&lt;/code&gt; doesn&amp;#39;t retain any reference to previous calls.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ok, so that&amp;#39;s what a closure isn&amp;#39;t, but what &lt;strong&gt;is&lt;/strong&gt; a closure?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In a closure those variables stick around for a while longer since there is a reference to the variables after the function returns.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function aClosure() {
    var longLivedVariable = "I'm here for a long time";
    var innerFunction = function inner() {
        return longLivedVariable;
    }
    return innerFunction;
}
var closure = aClosure(); // returns a reference to innerFunction
closure(); // returns "I'm here for a long time"
&lt;/pre&gt;
&lt;p&gt;Notice that &lt;code&gt;aClosure&lt;/code&gt; doesn&amp;#39;t return &lt;code&gt;longLivedVariable&lt;/code&gt;, but rather &lt;code&gt;innerFunction&lt;/code&gt;. This means there&amp;#39;s a reference hanging around to &lt;code&gt;innerFunction&lt;/code&gt;, and because &lt;code&gt;innerFunction&lt;/code&gt; has a reference to &lt;code&gt;longLivedVariable&lt;/code&gt;, that variable continues to exist.&lt;/p&gt;

&lt;p&gt;Finally, when we call &lt;code&gt;closure()&lt;/code&gt;, we&amp;#39;re really calling &lt;code&gt;innerFunction()&lt;/code&gt; (the returned value of &lt;code&gt;aClosure()&lt;/code&gt;), which in turn returns &lt;code&gt;longLivedVariable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Prove it, call the closure multiple times.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You got it.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function stillAClosure(anotherLongLivedVariable) {
    var innerFunction = function inner() {
        return anotherLongLivedVariable;
    }
    return innerFunction;
}
var closure = stillAClosure("The same string");
closure(); // returns "The same string"
closure(); // returns "The same string"
closure(); // returns "The same string"
&lt;/pre&gt;
&lt;p&gt;And here&amp;#39;s even more proof:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var closure1 = stillAClosure("String 1");
closure1(); // returns "String 1"
closure1(); // returns "String 1"

var closure2 = stillAClosure("String 2");
closure2(); // returns "String 2"
closure2(); // returns "String 2"

// And here's the kicker
closure1(); // returns "String 1"
&lt;/pre&gt;
&lt;p&gt;Bam! Did you see that! &lt;code&gt;closure1&lt;/code&gt; kept a reference to &lt;code&gt;&amp;quot;String 1&amp;quot;&lt;/code&gt; even though &lt;code&gt;stillAClosure&lt;/code&gt; had been called with a whole other parameter (namely &lt;code&gt;&amp;quot;String 2&amp;quot;&lt;/code&gt;). That&amp;#39;s some pretty cool stuff!&lt;/p&gt;

&lt;p&gt;&lt;em&gt;OK, I&amp;#39;m convinced. But now &lt;strong&gt;why&lt;/strong&gt; would I ever want to use a closure?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Well, since closures keep access to the variables they can be used to save state. And things that save state look a whole lot like objects. (Before I get any haters, I know you can use closures for a bunch of other things, but this is a reasonable example.)&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function cat(name) {
    return {
        sayName: function() {
            return name;
        }
    }
}

var fluffy = cat('Mr. Fluffy');
fluffy.name // returns undefined
fluffy.sayName() // returns 'Mr. Fluffy'

var whiskers = cat('Whiskers');
whiskers.sayName() // returns 'Whiskers'
&lt;/pre&gt;
&lt;p&gt;So this way you can create a whole bunch of &lt;code&gt;cat&lt;/code&gt; objects that have a private &lt;code&gt;name&lt;/code&gt; variable, which you can access via the &lt;code&gt;sayName&lt;/code&gt; method.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>A display of Scott Aaronson's Timeline of computer science</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/timeline-of-computer-science/"/>
    <id>http://lucybain.com/blog/2014/timeline-of-computer-science/</id>
    <published>2014-10-13T00:00:00Z</published>
    <updated>2014-10-13T17:55:06+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;
  The timeline might take some time to load, please be patient. I did not pick any of these events, they come directly from &lt;a href="http://www.scottaaronson.com/blog/?p=524"&gt;Scott Aaronson's Timeline of computer science&lt;/a&gt;, please don't hate on the events chosen. The timeline is made by &lt;a href="http://timeline.knightlab.com/"&gt;TimelineJS&lt;/a&gt;, please check it out!
&lt;/p&gt;
&lt;div class='timeline'&gt;
  &lt;iframe src='http://cdn.knightlab.com/libs/timeline/latest/embed/index.html?source=0AlyQ63WYoWl7dFVGSV95TmRyeFFNcVdNbWkzb2RPMXc&amp;font=Bevan-PotanoSans&amp;maptype=toner&amp;lang=en&amp;height=650' width='100%' height='650' frameborder='0'&gt;&lt;/iframe&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>JS: null, undefined, and undeclared</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/null-undefined-undeclared/"/>
    <id>http://lucybain.com/blog/2014/null-undefined-undeclared/</id>
    <published>2014-10-06T00:00:00Z</published>
    <updated>2014-10-06T17:11:28+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s the difference between a variable that is: null, undefined, or undeclared?&lt;/h2&gt;

&lt;p&gt;Here&amp;#39;s a &lt;a href="http://stackoverflow.com/a/834095/863846"&gt;TL;DR&lt;/a&gt; version I found quite useful when writing this.&lt;/p&gt;

&lt;p&gt;I think they make more sense in the opposite order: undeclared, undefined, and null. That&amp;#39;s the order I&amp;#39;m going to tackle them anyways.&lt;/p&gt;

&lt;p&gt;First up is &lt;strong&gt;&lt;code&gt;undeclared&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A variable is undeclared when it does not use the &lt;code&gt;var&lt;/code&gt; keyword. It gets created on the global object (that is, the window), thus it operates in a different space as the declared variables.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;undeclaredVariable = 1;
var declaredVariable = 1;

function changeVariables() {
  undeclaredVariable = 2;
  var declaredVariable = 2;
  var undeclaredVariable = 3;
}

changeVariables();

undeclaredVariable; // 2
declaredVariable; //1
&lt;/pre&gt;
&lt;p&gt;For more discussion on undeclared variables, checkout &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var"&gt;Mozilla&amp;#39;s documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now let&amp;#39;s move on to &lt;strong&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Something is &lt;code&gt;undefined&lt;/code&gt; when it hasn&amp;#39;t been defined yet. If you call a variable or function without having actually created it yet the parser will give you an &lt;code&gt;not defined&lt;/code&gt; error.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var undefinedVariable; // ReferenceError: undefinedVariable is not defined
typeof undefinedVariable; // "undefined"

undefinedFunction(); // ReferenceError: undefinedFunction is not defined
typeof undefinedFunction; // "undefined"
&lt;/pre&gt;
&lt;p&gt;Note that the &lt;code&gt;typeof&lt;/code&gt; returns &lt;code&gt;&amp;quot;undefined&amp;quot;&lt;/code&gt;, therefore &lt;code&gt;undefined&lt;/code&gt; is a primitive type.&lt;/p&gt;

&lt;p&gt;The fix for an undefined variable or function is easy, simply define it:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var definedVariable = 'test';
typeof definedVariable; // "string"

function definedFunction(){
  return "I'm defined!"
}
typeof definedFunction // "function"
&lt;/pre&gt;
&lt;p&gt;You can know if a variable is undefined with the following:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;if (typeof(variable) !== "undefined") {
  console.log('variable is not undefined');
} else {
  console.log('variable is undefined');
}
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Finally we&amp;#39;ll finish up with &lt;strong&gt;&lt;code&gt;null&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt; is a variable that is defined to have a null value.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var nullVariable = null; // null
typeof nullVariable // "object"
&lt;/pre&gt;
&lt;p&gt;You probably don&amp;#39;t often purposefully define a variable to &lt;code&gt;null&lt;/code&gt;, but it may be the return value of a function. Often you&amp;#39;ll need to gaurd against &lt;code&gt;null&lt;/code&gt; values in your code.&lt;/p&gt;

&lt;p&gt;You can know if a variable is null with the following:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;if( variable || variable === false ) {
  console.log('variable is not null');
} else {
  console.log('variable is null');
}
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;
I think the order &amp;quot;undeclared, undefined, and null&amp;quot; makes sense since it&amp;#39;s increasing order of certainty.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;undeclared&lt;/code&gt; variables don&amp;#39;t even exist&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; variables exist, but don&amp;#39;t have anything assigned to them&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt; variables exist and have null assigned to them&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS Immediately Invoked Function Expressions</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/immediately-invoked-function-expression/"/>
    <id>http://lucybain.com/blog/2014/immediately-invoked-function-expression/</id>
    <published>2014-10-01T00:00:00Z</published>
    <updated>2014-10-02T23:02:58+10:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;Explain why the following doesn&amp;#39;t work as an IIFE: &lt;code&gt;function foo(){ }();&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;What does &amp;quot;IIFE&amp;quot; even stand for?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;IIFE stands for Immediately Invoked Function Expressions&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Great, so what are IIFEs?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;An IIFE is an anonymous function that is created and then immediately invoked. It&amp;#39;s not called from anywhere else (hence why it&amp;#39;s anonymous), but runs just after being created.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;(function () {
  return 5;
} ());
// returns 5 right away
&lt;/pre&gt;
&lt;p&gt;They can be used to guard against &lt;strong&gt;unintended effects of hoisting:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The following code snip-it is from &lt;a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression#Evaluation_context"&gt;Wikipedia&lt;/a&gt;. I didn&amp;#39;t understand how it worked right away, but I wrote the explanation following the snip-it to clear up my confusion.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var v = 1;
var getValue = (function(x) {
  return function() { return x; };
}(v));
v = 2;

getValue(); // returns 1
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;I can&amp;#39;t even read that, what do all the nested functions mean?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s investigate the IIFE assigned to &lt;code&gt;getValue&lt;/code&gt; by rewriting it with a helper function:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var v = 1;

function helperFunction(x) {
  return function() {
    return x;
  };
}
var getValue = helperFunction(v); // returns an anonymous function

v = 2;

getValue(); // invokes that function
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;What happens when the &lt;code&gt;var getValue = helperFunction(v)&lt;/code&gt; line is called?&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;helperFunction(v)&lt;/code&gt; gets called with the current value of &lt;code&gt;v&lt;/code&gt;, which is 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;helperFunction&lt;/code&gt; gets executed, with the param &lt;code&gt;x&lt;/code&gt; set to 1&lt;/li&gt;
&lt;li&gt;The anonymous function returned by &lt;code&gt;helperFunction&lt;/code&gt; gets created, still with &lt;code&gt;x&lt;/code&gt; set to 1&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;getValue&lt;/code&gt; is set to the result of &lt;code&gt;helperFunction&lt;/code&gt;, which is&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function() {
  return 1;
};
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So now things look like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var v = 1;
var getValue = function() {
                 return 1;
               };
v = 2;

getValue();
&lt;/pre&gt;
&lt;p&gt;And from here it is hardly surprising that &lt;code&gt;getValue()&lt;/code&gt; returns 1.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What would have happened without the IIFE?&lt;/em&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var v = 1;
var getValue = function() {
                  return v;
               };
v = 2;

getValue(); // returns 2
&lt;/pre&gt;
&lt;p&gt;Although the &lt;code&gt;return v&lt;/code&gt; is written when &lt;code&gt;v&lt;/code&gt; is 1, by the time &lt;code&gt;getValue&lt;/code&gt; is called &lt;code&gt;v&lt;/code&gt; has been set to 2. Thus &lt;code&gt;getValue()&lt;/code&gt; actually returns 2.&lt;/p&gt;

&lt;p&gt;IIFEs can also be used to enforce &lt;strong&gt;private variables and methods:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Again, the example is taken by &lt;a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression#Establishing_private_variables_and_accessors"&gt;Wikipedia&lt;/a&gt; (slightly simplified), and the explanation is my own.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var counter = (function(){
  var i = 0;

  return {
    get: function(){
      return i;
    },
    set: function( val ){
      i = val;
    }
  };
}());

counter.get(); // returns 0
counter.set( 3 ); // returns undefined
counter.get(); // returns 3
counter.i; // returns undefined
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Again with the confusing nested functions! Can I have a rewrite?&lt;/em&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function helperFunction(){
  var i = 0;

  return {
    get: function(){
      return i;
    },
    set: function( val ){
      i = val;
    }
  };
};

var counter = helperFunction();

counter.get(); // returns 0
counter.set( 3 ); // returns undefined
counter.get(); // returns 3
counter.i; // returns undefined
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Ok, that&amp;#39;s a bit clearer, but what is &lt;code&gt;counter&lt;/code&gt; actually set to?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;counter&lt;/code&gt; is set to the return value of &lt;code&gt;helperFunction&lt;/code&gt;, that is just this bit:&lt;/p&gt;
&lt;pre class="highlight json"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="err"&gt;get&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;function()&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="err"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;i;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="err"&gt;set&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;function(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="err"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;val;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;You&amp;#39;ll notice &lt;code&gt;var i&lt;/code&gt; doesn&amp;#39;t appear anywhere in there. &lt;code&gt;i&lt;/code&gt; is defined elsewhere in the &lt;code&gt;helperFunction&lt;/code&gt; / IIFE. Since the return value of &lt;code&gt;helperFunction&lt;/code&gt; doesn&amp;#39;t give explicit access to &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;counter&lt;/code&gt; doesn&amp;#39;t have access.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fine, so if that&amp;#39;s all that &lt;code&gt;counter&lt;/code&gt; has access to, how does &lt;code&gt;counter.get()&lt;/code&gt; return a value?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Scopes! The scope from &lt;code&gt;helperFunction&lt;/code&gt; has access to &lt;code&gt;i&lt;/code&gt;. The object returned by &lt;code&gt;helperFunction&lt;/code&gt; (a.k.a &lt;code&gt;counter&lt;/code&gt;) has access to all the variables defined in &lt;code&gt;helperFunction&lt;/code&gt;. It works like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Call to &lt;code&gt;counter.get()&lt;/code&gt; goes and looks at the &lt;code&gt;get&lt;/code&gt; function defined in &lt;code&gt;helperFunction&lt;/code&gt;...&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;get: function(){
    return i;
   }
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; function looks for it&amp;#39;s local scope, which is &lt;code&gt;helperFunction&lt;/code&gt; ...&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function helperFunction(){
var i = 0;

return {
  get: function(){
    return i;
  },
  set: function( val ){
    i = val;
  }
};
};
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In &lt;code&gt;helperFunction&lt;/code&gt; is a definition for &lt;code&gt;i&lt;/code&gt;...&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var i = 0;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;So &lt;code&gt;get&lt;/code&gt; can return 0!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;And now back to your scheduled program&lt;/h3&gt;

&lt;p&gt;With all that explanation behind us, let&amp;#39;s go back to the original question:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain why the following doesn&amp;#39;t work as an IIFE: &lt;code&gt;function foo(){ }();&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Because &lt;code&gt;foo&lt;/code&gt; isn&amp;#39;t being called! Here&amp;#39;s a rewrite:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function foo(){
}();
&lt;/pre&gt;
&lt;p&gt;This is a function &lt;strong&gt;definition&lt;/strong&gt;, it defines &lt;code&gt;foo&lt;/code&gt;. But it&amp;#39;s not a function &lt;strong&gt;expression&lt;/strong&gt; - that is, it&amp;#39;s not understood by the JS parser to actually call a function.&lt;/p&gt;

&lt;p&gt;For the parser, things look like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function foo(){
} // ok, done with that function definition
  // (silly human left off the semicolon, how embarrassing!)

(); // Are they trying to call something? What's the function's name?
    // PARSE ERROR
&lt;/pre&gt;
&lt;p&gt;In order to prep the parser that we&amp;#39;re actually dealing with a function &lt;strong&gt;expression&lt;/strong&gt; we have to wrap things up in &lt;code&gt;()&lt;/code&gt; like so:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;(
  function foo(){
  }()
);
&lt;/pre&gt;
&lt;p&gt;Now the parser reads this as:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;( // oh goody, we're going to call some function expressions!
  function foo(){ // here's the function definition
  }() // and here's where the function is actually called
);
&lt;/pre&gt;
&lt;p&gt;And to finish it all off with a return statement and everything:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;(function foo(){
  return 'bar';
}());
&lt;/pre&gt;
&lt;p&gt;For more information read Ben Alman&amp;#39;s post &lt;a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/"&gt;introducing IIFEs&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
</feed>
