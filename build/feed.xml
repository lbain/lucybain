<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucy Bain</title>
  <id>http://lucybain.com/blog</id>
  <link href="http://lucybain.com/blog"/>
  <link href="http://lucybain.com/feed.xml" rel="self"/>
  <updated>2014-10-13T00:00:00Z</updated>
  <author>
    <name>Lucy Bain</name>
  </author>
  <entry>
    <title>A display of Scott Aaronson's Timeline of computer science</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/timeline-of-computer-science/"/>
    <id>http://lucybain.com/blog/2014/timeline-of-computer-science/</id>
    <published>2014-10-13T00:00:00Z</published>
    <updated>2014-10-13T17:55:06+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;
  The timeline might take some time to load, please be patient. I did not pick any of these events, they come directly from &lt;a href="http://www.scottaaronson.com/blog/?p=524"&gt;Scott Aaronson's Timeline of computer science&lt;/a&gt;, please don't hate on the events chosen. The timeline is made by &lt;a href="http://timeline.knightlab.com/"&gt;TimelineJS&lt;/a&gt;, please check it out!
&lt;/p&gt;
&lt;div class='timeline'&gt;
  &lt;iframe src='http://cdn.knightlab.com/libs/timeline/latest/embed/index.html?source=0AlyQ63WYoWl7dFVGSV95TmRyeFFNcVdNbWkzb2RPMXc&amp;font=Bevan-PotanoSans&amp;maptype=toner&amp;lang=en&amp;height=650' width='100%' height='650' frameborder='0'&gt;&lt;/iframe&gt;
&lt;/div&gt;
</content>
  </entry>
  <entry>
    <title>JS: null, undefined, and undeclared</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/null-undefined-undeclared/"/>
    <id>http://lucybain.com/blog/2014/null-undefined-undeclared/</id>
    <published>2014-10-06T00:00:00Z</published>
    <updated>2014-10-06T17:11:28+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s the difference between a variable that is: null, undefined, or undeclared?&lt;/h2&gt;

&lt;p&gt;Here&amp;#39;s a &lt;a href="http://stackoverflow.com/a/834095/863846"&gt;TL;DR&lt;/a&gt; version I found quite useful when writing this.&lt;/p&gt;

&lt;p&gt;I think they make more sense in the opposite order: undeclared, undefined, and null. That&amp;#39;s the order I&amp;#39;m going to tackle them anyways.&lt;/p&gt;

&lt;p&gt;First up is &lt;strong&gt;&lt;code&gt;undeclared&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;A variable is undeclared when it does not use the &lt;code&gt;var&lt;/code&gt; keyword. It gets created on the global object (that is, the window), thus it operates in a different space as the declared variables.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;undeclaredVariable = 1;
var declaredVariable = 1;

function changeVariables() {
  undeclaredVariable = 2;
  var declaredVariable = 2;
  var undeclaredVariable = 3;
}

changeVariables();

undeclaredVariable; // 2
declaredVariable; //1
&lt;/pre&gt;
&lt;p&gt;For more discussion on undeclared variables, checkout &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var"&gt;Mozilla&amp;#39;s documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Now let&amp;#39;s move on to &lt;strong&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Something is &lt;code&gt;undefined&lt;/code&gt; when it hasn&amp;#39;t been defined yet. If you call a variable or function without having actually created it yet the parser will give you an &lt;code&gt;not defined&lt;/code&gt; error.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var undefinedVariable; // ReferenceError: undefinedVariable is not defined
typeof undefinedVariable; // "undefined"

undefinedFunction(); // ReferenceError: undefinedFunction is not defined
typeof undefinedFunction; // "undefined"
&lt;/pre&gt;
&lt;p&gt;Note that the &lt;code&gt;typeof&lt;/code&gt; returns &lt;code&gt;&amp;quot;undefined&amp;quot;&lt;/code&gt;, therefore &lt;code&gt;undefined&lt;/code&gt; is a primitive type.&lt;/p&gt;

&lt;p&gt;The fix for an undefined variable or function is easy, simply define it:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var definedVariable = 'test';
typeof definedVariable; // "string"

function definedFunction(){
  return "I'm defined!"
}
typeof definedFunction // "function"
&lt;/pre&gt;
&lt;p&gt;You can know if a variable is undefined with the following:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;if (typeof(variable) !== "undefined") {
  console.log('variable is not undefined');
} else {
  console.log('variable is undefined');
}
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;

&lt;p&gt;Finally we&amp;#39;ll finish up with &lt;strong&gt;&lt;code&gt;null&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;null&lt;/code&gt; is a variable that is defined to have a null value.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var nullVariable = null; // null
typeof nullVariable // "object"
&lt;/pre&gt;
&lt;p&gt;You probably don&amp;#39;t often purposefully define a variable to &lt;code&gt;null&lt;/code&gt;, but it may be the return value of a function. Often you&amp;#39;ll need to gaurd against &lt;code&gt;null&lt;/code&gt; values in your code.&lt;/p&gt;

&lt;p&gt;You can know if a variable is null with the following:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;if( variable || variable === false ) {
  console.log('variable is not null');
} else {
  console.log('variable is null');
}
&lt;/pre&gt;
&lt;p&gt;&lt;br/&gt;
I think the order &amp;quot;undeclared, undefined, and null&amp;quot; makes sense since it&amp;#39;s increasing order of certainty.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;undeclared&lt;/code&gt; variables don&amp;#39;t even exist&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt; variables exist, but don&amp;#39;t have anything assigned to them&lt;/li&gt;
&lt;li&gt;&lt;code&gt;null&lt;/code&gt; variables exist and have null assigned to them&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS Immediately Invoked Function Expressions</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/immediately-invoked-function-expression/"/>
    <id>http://lucybain.com/blog/2014/immediately-invoked-function-expression/</id>
    <published>2014-10-01T00:00:00Z</published>
    <updated>2014-10-02T23:02:58+10:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;Explain why the following doesn&amp;#39;t work as an IIFE: &lt;code&gt;function foo(){ }();&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;What does &amp;quot;IIFE&amp;quot; even stand for?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;IIFE stands for Immediately Invoked Function Expressions&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Great, so what are IIFEs?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;An IIFE is an anonymous function that is created and then immediately invoked. It&amp;#39;s not called from anywhere else (hence why it&amp;#39;s anonymous), but runs just after being created.&lt;/p&gt;

&lt;p&gt;Example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;(function () {
  return 5;
} ());
// returns 5 right away
&lt;/pre&gt;
&lt;p&gt;They can be used to guard against &lt;strong&gt;unintended effects of hoisting:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The following code snip-it is from &lt;a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression#Evaluation_context"&gt;Wikipedia&lt;/a&gt;. I didn&amp;#39;t understand how it worked right away, but I wrote the explanation following the snip-it to clear up my confusion.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var v = 1;
var getValue = (function(x) {
  return function() { return x; };
}(v));
v = 2;

getValue(); // returns 1
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;I can&amp;#39;t even read that, what do all the nested functions mean?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s investigate the IIFE assigned to &lt;code&gt;getValue&lt;/code&gt; by rewriting it with a helper function:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var v = 1;

function helperFunction(x) {
  return function() {
    return x;
  };
}
var getValue = helperFunction(v); // returns an anonymous function

v = 2;

getValue(); // invokes that function
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;What happens when the &lt;code&gt;var getValue = helperFunction(v)&lt;/code&gt; line is called?&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;helperFunction(v)&lt;/code&gt; gets called with the current value of &lt;code&gt;v&lt;/code&gt;, which is 1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;helperFunction&lt;/code&gt; gets executed, with the param &lt;code&gt;x&lt;/code&gt; set to 1&lt;/li&gt;
&lt;li&gt;The anonymous function returned by &lt;code&gt;helperFunction&lt;/code&gt; gets created, still with &lt;code&gt;x&lt;/code&gt; set to 1&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;getValue&lt;/code&gt; is set to the result of &lt;code&gt;helperFunction&lt;/code&gt;, which is&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function() {
  return 1;
};
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So now things look like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var v = 1;
var getValue = function() {
                 return 1;
               };
v = 2;

getValue();
&lt;/pre&gt;
&lt;p&gt;And from here it is hardly surprising that &lt;code&gt;getValue()&lt;/code&gt; returns 1.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What would have happened without the IIFE?&lt;/em&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var v = 1;
var getValue = function() {
                  return v;
               };
v = 2;

getValue(); // returns 2
&lt;/pre&gt;
&lt;p&gt;Although the &lt;code&gt;return v&lt;/code&gt; is written when &lt;code&gt;v&lt;/code&gt; is 1, by the time &lt;code&gt;getValue&lt;/code&gt; is called &lt;code&gt;v&lt;/code&gt; has been set to 2. Thus &lt;code&gt;getValue()&lt;/code&gt; actually returns 2.&lt;/p&gt;

&lt;p&gt;IIFEs can also be used to enforce &lt;strong&gt;private variables and methods:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Again, the example is taken by &lt;a href="https://en.wikipedia.org/wiki/Immediately-invoked_function_expression#Establishing_private_variables_and_accessors"&gt;Wikipedia&lt;/a&gt; (slightly simplified), and the explanation is my own.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var counter = (function(){
  var i = 0;

  return {
    get: function(){
      return i;
    },
    set: function( val ){
      i = val;
    }
  };
}());

counter.get(); // returns 0
counter.set( 3 ); // returns undefined
counter.get(); // returns 3
counter.i; // returns undefined
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Again with the confusing nested functions! Can I have a rewrite?&lt;/em&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function helperFunction(){
  var i = 0;

  return {
    get: function(){
      return i;
    },
    set: function( val ){
      i = val;
    }
  };
};

var counter = helperFunction();

counter.get(); // returns 0
counter.set( 3 ); // returns undefined
counter.get(); // returns 3
counter.i; // returns undefined
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Ok, that&amp;#39;s a bit clearer, but what is &lt;code&gt;counter&lt;/code&gt; actually set to?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;counter&lt;/code&gt; is set to the return value of &lt;code&gt;helperFunction&lt;/code&gt;, that is just this bit:&lt;/p&gt;
&lt;pre class="highlight json"&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="err"&gt;get&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;function()&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="err"&gt;return&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;i;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="err"&gt;set&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;function(&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;val&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;
    &lt;/span&gt;&lt;span class="err"&gt;i&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;val;&lt;/span&gt;&lt;span class="w"&gt;
  &lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="err"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;You&amp;#39;ll notice &lt;code&gt;var i&lt;/code&gt; doesn&amp;#39;t appear anywhere in there. &lt;code&gt;i&lt;/code&gt; is defined elsewhere in the &lt;code&gt;helperFunction&lt;/code&gt; / IIFE. Since the return value of &lt;code&gt;helperFunction&lt;/code&gt; doesn&amp;#39;t give explicit access to &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;counter&lt;/code&gt; doesn&amp;#39;t have access.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Fine, so if that&amp;#39;s all that &lt;code&gt;counter&lt;/code&gt; has access to, how does &lt;code&gt;counter.get()&lt;/code&gt; return a value?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Scopes! The scope from &lt;code&gt;helperFunction&lt;/code&gt; has access to &lt;code&gt;i&lt;/code&gt;. The object returned by &lt;code&gt;helperFunction&lt;/code&gt; (a.k.a &lt;code&gt;counter&lt;/code&gt;) has access to all the variables defined in &lt;code&gt;helperFunction&lt;/code&gt;. It works like this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Call to &lt;code&gt;counter.get()&lt;/code&gt; goes and looks at the &lt;code&gt;get&lt;/code&gt; function defined in &lt;code&gt;helperFunction&lt;/code&gt;...&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;get: function(){
    return i;
   }
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;get&lt;/code&gt; function looks for it&amp;#39;s local scope, which is &lt;code&gt;helperFunction&lt;/code&gt; ...&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function helperFunction(){
var i = 0;

return {
  get: function(){
    return i;
  },
  set: function( val ){
    i = val;
  }
};
};
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In &lt;code&gt;helperFunction&lt;/code&gt; is a definition for &lt;code&gt;i&lt;/code&gt;...&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var i = 0;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;So &lt;code&gt;get&lt;/code&gt; can return 0!&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3&gt;And now back to your scheduled program&lt;/h3&gt;

&lt;p&gt;With all that explanation behind us, let&amp;#39;s go back to the original question:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Explain why the following doesn&amp;#39;t work as an IIFE: &lt;code&gt;function foo(){ }();&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Because &lt;code&gt;foo&lt;/code&gt; isn&amp;#39;t being called! Here&amp;#39;s a rewrite:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function foo(){
}();
&lt;/pre&gt;
&lt;p&gt;This is a function &lt;strong&gt;definition&lt;/strong&gt;, it defines &lt;code&gt;foo&lt;/code&gt;. But it&amp;#39;s not a function &lt;strong&gt;expression&lt;/strong&gt; - that is, it&amp;#39;s not understood by the JS parser to actually call a function.&lt;/p&gt;

&lt;p&gt;For the parser, things look like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function foo(){
} // ok, done with that function definition
  // (silly human left off the semicolon, how embarrassing!)

(); // Are they trying to call something? What's the function's name?
    // PARSE ERROR
&lt;/pre&gt;
&lt;p&gt;In order to prep the parser that we&amp;#39;re actually dealing with a function &lt;strong&gt;expression&lt;/strong&gt; we have to wrap things up in &lt;code&gt;()&lt;/code&gt; like so:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;(
  function foo(){
  }()
);
&lt;/pre&gt;
&lt;p&gt;Now the parser reads this as:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;( // oh goody, we're going to call some function expressions!
  function foo(){ // here's the function definition
  }() // and here's where the function is actually called
);
&lt;/pre&gt;
&lt;p&gt;And to finish it all off with a return statement and everything:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;(function foo(){
  return 'bar';
}());
&lt;/pre&gt;
&lt;p&gt;For more information read Ben Alman&amp;#39;s post &lt;a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/"&gt;introducing IIFEs&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>JS prototypal inheritance</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/prototypal-inheritance/"/>
    <id>http://lucybain.com/blog/2014/prototypal-inheritance/</id>
    <published>2014-09-30T00:00:00Z</published>
    <updated>2014-10-01T22:40:42+10:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;Explain how prototypal inheritance works&lt;/h2&gt;

&lt;p&gt;JS objects each have a &amp;quot;hook&amp;quot; to it&amp;#39;s parent object, or prototype. Obviously everything the child object defines it has access to, but it also can climb up the prototype tree to access it&amp;#39;s parent&amp;#39;s (or ancesstor&amp;#39;s) methods and properties.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(the obligatory animal) Example:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function Animal(){
  this.alive = true;
}

function Mammal() {
  this.warmBlooded = true;
  this.hasTail = false;
  this.move = function(){
    if(this.hasTail){
      return "Moving with tail";
    } else {
      return "Moving with tail";
    }
  };
}
Mammal.prototype = new Animal();

function Cat(name) {
  this.sound = 'Meow';
  this.hasTail = true;
  this.name = name;
  this.greet = function() {
    return "Hello, I'm " + this.name;
  };
}
Cat.prototype = new Mammal();

var mittens = new Cat('Mittens');

mittens.sound; // returns 'Meow' (as defined on Cat)

mittens.hasTail; // returns true (as defined on Cat)
  // Although Mammal also defines hasTail, the Cat's
  // definition takes precidence

mittens.warmBlooded; // returns true (as defined on Mammal)

mittens.alive; // returns true (as defined on Animal)

mittens.greet() // returns "Hello, I'm Mittens"
  // greet() accesses the "name" attribute defined on Cat

mittens.move() // returns "Moving with tail"
  // move() accesses the "hasTail" attribute which is defined
  // on Cat and Mammal. Although Mammal defines the move function
  // "this" refers to mittens, so move() uses mitten's "hasTail"
  // attribute, which is set to true
&lt;/pre&gt;
&lt;p&gt;There&amp;#39;s a longer explaination from &lt;a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain"&gt;Mozilla&lt;/a&gt;.&lt;/p&gt;
</content>
  </entry>
  <entry>
    <title>JS "this"</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/explaination-of-this/"/>
    <id>http://lucybain.com/blog/2014/explaination-of-this/</id>
    <published>2014-09-29T00:00:00Z</published>
    <updated>2014-10-01T22:41:06+10:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;Explain how this works in JavaScript&lt;/h2&gt;

&lt;p&gt;Huh, well that&amp;#39;s something I&amp;#39;ve been trying to figure out as I work with JS. &lt;code&gt;this&lt;/code&gt; still doesn&amp;#39;t make perfect sense to me. But here&amp;#39;s my current understanding...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;this&lt;/code&gt; is the context the code is running in&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;However, the context seems to change a lot, and I find it rather confusing. So I signed upf for an &lt;a href="http://derickbailey.com/email-courses/masteringthis/"&gt;email series&lt;/a&gt; on how &lt;code&gt;this&lt;/code&gt; can change. Here&amp;#39;s a sweeping overview of that series:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; refers to the window&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At it&amp;#39;s simplest, &lt;code&gt;this&lt;/code&gt; is the window itself without anything fancy going on. You can call &lt;code&gt;this&lt;/code&gt; in the console directly and get Window.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; refers to the object it&amp;#39;s being called from&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight javascript"&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;currentYear&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2014&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;person&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="na"&gt;birthYear&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;1977&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
               &lt;span class="na"&gt;getAge&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                 &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;currentYear&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;birthYear&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
               &lt;span class="p"&gt;}&lt;/span&gt;
             &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nx"&gt;person&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getAge&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="c1"&gt;// returns 37
&lt;/span&gt;&lt;/pre&gt;
&lt;p&gt;You can see the call to &lt;code&gt;this.birthYear&lt;/code&gt; in the &lt;code&gt;getAge&lt;/code&gt; function references the &lt;code&gt;person&lt;/code&gt;&amp;#39;s &lt;code&gt;birthYear&lt;/code&gt;. That is the &lt;code&gt;this&lt;/code&gt; refers to it&amp;#39;s parent object. As a Ruby developer &lt;code&gt;this&lt;/code&gt; is similar to &lt;code&gt;self&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; refers to the element the event is bound to&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="highlight javascript"&gt;&lt;span class="nx"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'a'&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'click'&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="nx"&gt;console&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;log&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;target&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// logs true
&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;Here the &lt;code&gt;this&lt;/code&gt; refers to the link the user clicked on, just like &lt;code&gt;event.target&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;this&lt;/code&gt; refers to the context that was explicitly set&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Apparently you can use &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;apply&lt;/code&gt; and pass a context explicitly. In that case &lt;code&gt;this&lt;/code&gt; refers to the passed context.&lt;/p&gt;
&lt;pre class="highlight javascript"&gt;&lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="nx"&gt;greeter&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s1"&gt;'Hello '&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;'!'&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;passableContext&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;'world'&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nx"&gt;greeter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;passableContext&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;// returns 'Hello world!'
&lt;/span&gt;&lt;/pre&gt;</content>
  </entry>
  <entry>
    <title>JS event delegation</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/event-delegation/"/>
    <id>http://lucybain.com/blog/2014/event-delegation/</id>
    <published>2014-09-25T00:00:00Z</published>
    <updated>2014-10-01T22:26:04+10:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;
  I'm continuing my JS learning and found a list of &lt;a href="https://github.com/darcyclarke/Front-end-Developer-Interview-Questions"&gt;front end interview questions&lt;/a&gt;. There's a section devoted to JS on there for me to work through. If they're important enough to know in an interview I should probably know about them too.
&lt;/p&gt;
&lt;h2&gt;Explain event delegation&lt;/h2&gt;
&lt;p&gt;
  Well I'm glad you asked. As it turns out we covered this topic in my &lt;a href="http://codesydney.com"&gt;JS study group&lt;/a&gt; when I wrote my &lt;a href="code-sydney-work/tic-tac-toe/"&gt;Tic Tac Toe game.&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;
  Event delegation is when you bind an event listener to a parent (or ancestor) element rather than the element(s) you are particularly interested in. When the event is triggered you can check the event target to make sure it was actually the triggered on the element of interest. In general this would be inefficient as you're now listening to events on the parent, and have to filter out any that aren't on the particular element of interest. However, event delegation is particularly useful when you have many siblings (or decedents of the ancestor) that you're interested in.
&lt;/p&gt;
&lt;p&gt;
  A simple example is as follows:
&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&amp;lt;ul&amp;gt;&amp;#x000A;  &amp;lt;li&amp;gt; First list element &amp;lt;/li&amp;gt;&amp;#x000A;  &amp;lt;li&amp;gt; Second list element &amp;lt;/li&amp;gt;&amp;#x000A;  &amp;lt;li&amp;gt; Third list element &amp;lt;/li&amp;gt;&amp;#x000A;&amp;lt;/ul&amp;gt;&amp;#x000A;&lt;/pre&gt;
&lt;p&gt;
  While it would be possible to bind to the individual &lt;code&gt;li&lt;/code&gt; elements it would require 3 listeners. Using event delegation it is possible to bind one event listener to the &lt;code&gt;ul&lt;/code&gt; element and just check if the event's target is an li element (very likely in this case...).
&lt;/p&gt;
&lt;p&gt;
  For my Tic Tac Toe game I listened to all click events on the board, and then checked the particular cell they clicked on, rather than listening for events on all the cells at once.
&lt;/p&gt;
</content>
  </entry>
</feed>
