<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucy Bain</title>
  <id>http://lucybain.com/blog</id>
  <link href="http://lucybain.com/blog"/>
  <link href="http://lucybain.com/feed.xml" rel="self"/>
  <updated>2014-12-16T00:00:00Z</updated>
  <author>
    <name>Lucy Bain</name>
  </author>
  <entry>
    <title>JS: document load vs document ready</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/js-document-load-vs-ready/"/>
    <id>http://lucybain.com/blog/2014/js-document-load-vs-ready/</id>
    <published>2014-12-16T00:00:00Z</published>
    <updated>2014-12-16T20:24:59+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;Difference between document load event and document ready event?&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;$(document).ready()&lt;/code&gt;&lt;/strong&gt; fires when the HTML has finished loading. You can&amp;#39;t interact with the DOM before the HTML has finished loading, so we keep all our JS interactions wrapped up in the ready handler.&lt;/p&gt;

&lt;p&gt;Note: The ready event is just for jQuery, so that&amp;#39;s a downside if you weren&amp;#39;t planning on including all of jQuery on your site.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;window.onload&lt;/code&gt;&lt;/strong&gt; fires when all of the content (images, scripts, CSS, the whole lot) has finished loading. This can be really slow, so we try not to keep too much here. But it can be useful if you need to work with images of unknown size.&lt;/p&gt;

&lt;p&gt;And that&amp;#39;s it! This has been the most straight forward answer yet :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/3698200/window-onload-vs-document-ready"&gt;Stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Another &lt;a href="http://stackoverflow.com/questions/7971615/difference-between-pageload-onload-document-ready"&gt;stackoverflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;There were a bunch more, but they all said the same thing.&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: Explain "hoisting"</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/hoisting/"/>
    <id>http://lucybain.com/blog/2014/hoisting/</id>
    <published>2014-12-13T00:00:00Z</published>
    <updated>2014-12-13T20:32:34+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;I&amp;#39;m continuing my series of &lt;a href="https://github.com/h5bp/Front-end-Developer-Interview-Questions#js"&gt;JS interview questions&lt;/a&gt;. These posts are proving very good practice for the interviews I&amp;#39;m doing!&lt;/p&gt;

&lt;h2&gt;Explain &amp;quot;hoisting&amp;quot;&lt;/h2&gt;

&lt;p&gt;Hoisting is when a JS declaration is lifted (&amp;quot;hoisted&amp;quot;) to the top of it&amp;#39;s scope by the JS interpreter. What this really means is that a variable or function isn&amp;#39;t necessarily declared where you think it is. Understandably, this can cause problems. Variables and functions are hoisted differently, as we&amp;#39;ll see below.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hoisting variables&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We&amp;#39;ll start with an example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;// Code saved in file:

function containsHoisting() {
    console.log(hoistedVariable);
    var hoistedVariable = "I was hoisted!";
}

containsHoisting(); // logs undefined
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Wait, how did &lt;code&gt;hoistedVariable&lt;/code&gt; get to be undefined? Surely it should be undeclared since we haven&amp;#39;t hit &lt;code&gt;var hoistedVariable&lt;/code&gt; yet.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It&amp;#39;s because of hoisting! You see, although I wrote the code in the example above, the JS interpreter changes it to this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;// What the interpreter changed it to:

function containsHoisting() {
    var hoistedVariable; // &amp;lt;-- this line here!
    console.log(hoistedVariable);
    hoistedVariable = "I was hoisted!";
}
&lt;/pre&gt;
&lt;p&gt;That new line is &lt;code&gt;hoistedVariable&lt;/code&gt; getting hoisted up to the top of it&amp;#39;s scope. So it&amp;#39;s now declared, but not defined.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s a more complex example (inspired by &lt;a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html"&gt;Adequately Good&lt;/a&gt;)&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var hoistedVariable = 1;

function scopingFunction() {
    if (!hoistedVariable) {
        var hoistedVariable = 10;
    }
    return hoistedVariable;
}

scopingFunction(); // returns 10
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;What?! How can it return 10?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Tangent about scopes&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I was surprised about this myself until I understood JS scoping better, here&amp;#39;s how it breaks down:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In Javascript scopes are defined at &lt;strong&gt;function level&lt;/strong&gt;. Many other languages define scope at a block level (as in an &lt;code&gt;if&lt;/code&gt; block or &lt;code&gt;for&lt;/code&gt; loop). This is an important difference to remember.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Thus...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Back to the main event&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The code above gets rewritten in the JS interpreter to look like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var hoistedVariable = 1;

function scopingFunction() {
    var hoistedVariable; // &amp;lt;-- this line here!
    if (!hoistedVariable) {
        hoistedVariable = 10;
    }
    return hoistedVariable;
}

scopingFunction(); // returns 10
&lt;/pre&gt;
&lt;p&gt;Note that the &lt;em&gt;global&lt;/em&gt; &lt;code&gt;hoistedVariable&lt;/code&gt; gets completely overwritten by the &lt;em&gt;local&lt;/em&gt; &lt;code&gt;hoistedVariable&lt;/code&gt; as declared in &lt;code&gt;scopingFunction&lt;/code&gt;. So at the point of the &lt;code&gt;if&lt;/code&gt; conditional &lt;code&gt;hoistedVariable&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt; and not 1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Function hoisting&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Hoisting functions works differently than variables. Since a function is declared and defined at the same time the function definition is hoisted along with the function name.&lt;/p&gt;

&lt;p&gt;Since examples make things clearer:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function containingFunction() {
    var hoistedVariable = 2 + 2;
    function hoistedFunction() {
        return hoistedVariable;
    }
    return hoistedFunction();
}
containingFunction() // returns 4
&lt;/pre&gt;
&lt;p&gt;Hopefully that example wasn&amp;#39;t surprising. But just to better understand what&amp;#39;s going on, here&amp;#39;s how the JS interpreter rewrote things:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function containingFunction() {
    // this is the hoisted section
    var hoistedVariable;
    function hoistedFunction() {
        return hoistedVariable;
    }

    // here's the rest of the code
    hoistedVariable = 2 + 2;
    return hoistedFunction();
}
containingFunction() // returns 4
&lt;/pre&gt;
&lt;p&gt;Notice that the entire &lt;code&gt;hoistedFunction&lt;/code&gt; gets moved up, while only the declaration for the &lt;code&gt;hoistedVariable&lt;/code&gt; is hoisted.&lt;/p&gt;

&lt;p&gt;Let&amp;#39;s try with a more complicated example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function containingFunction() {
    var hoisted = "I'm the variable";
    function hoisted() {
        return "I'm the function";
    }
    return hoisted(); // results in a TypeError
}
containingFunction()
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;But wait, the &lt;code&gt;hoisted&lt;/code&gt; function is defined right there, what gives?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Because functions are hoisted after variables, naming conflicts can happen. Again, let&amp;#39;s look at what the JS interpreter wrote for this code&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function containingFunction() {
    // hoisted section
    var hoisted;
    function hoisted() {
        return "I'm the function";
    }

    // rest of the code
    hoisted = "I'm the variable";
    return hoisted();
}
containingFunction() // results in a TypeError
&lt;/pre&gt;
&lt;p&gt;As you can see, the function definition for &lt;code&gt;hoisted&lt;/code&gt; is overwritten by the variable definition (&lt;code&gt;&amp;quot;I&amp;#39;m the variable&amp;quot;&lt;/code&gt;) which appears lower down in the interpreter&amp;#39;s version of the code. Yet another reason why good names are important!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://javascriptissexy.com/javascript-variable-scope-and-hoisting-explained/"&gt;JS is sexy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html"&gt;Adequately Good&lt;/a&gt; (which I think is a hilarious name for a coding blog!)&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: Async Google Adwords conversion</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/google-adwords-async/"/>
    <id>http://lucybain.com/blog/2014/google-adwords-async/</id>
    <published>2014-12-10T00:00:00Z</published>
    <updated>2014-12-10T12:14:53+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;How can I trigger a Google Adwords conversion when the page is loaded asynchronously?&lt;/h2&gt;

&lt;p&gt;I&amp;#39;ve been working with Google Adwords at work this week (yay learning!). My first task was to add a &amp;quot;tracking pixel&amp;quot; to a thank you page after a user has given us their contact details.&lt;/p&gt;

&lt;p&gt;(Side note: It turns out we don&amp;#39;t really use pixels any more, we use JS to actually make the call, and only fall back to a pixel when the user doesn&amp;#39;t have JS enabled.)&lt;/p&gt;

&lt;p&gt;Our thank you page is loaded asynchronously, so the Google Adwords script was getting injected into the dom in that async call. As it turns out, you can&amp;#39;t just inject scripts into the dom and expect them to run. If you do inject the script (as I did) you&amp;#39;ll get this warning in Chrome:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;Failed to execute 'write' on 'Document': It isn't possible to write into a document from an asynchronously-loaded external script unless it is explicitly opened.
&lt;/pre&gt;
&lt;p&gt;(Personally I think this should be an error, not just a warning. To me, this is saying &amp;quot;Hey, your code that you think is running isn&amp;#39;t actually running&amp;quot; - that sounds like an error. But I digress...)&lt;/p&gt;

&lt;p&gt;After some Googling around I know of two ways to fix this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fix one (bad)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mess with &lt;code&gt;document.write&lt;/code&gt;. Basically Chrome has a check that an async loaded script doesn&amp;#39;t make any calls to &lt;code&gt;document.write&lt;/code&gt;. But it doesn&amp;#39;t check for &lt;code&gt;$(&amp;#39;body&amp;#39;).append()&lt;/code&gt; (yet). So if you set &lt;code&gt;document.write&lt;/code&gt; to actually use &lt;code&gt;$(&amp;#39;body&amp;#39;).append()&lt;/code&gt; the error goes away. Here&amp;#39;s an example (taken from &lt;a href="http://www.jakobbeyer.de/asynchronous-google-adwords-conversion-tracking"&gt;Jakob Beyer&lt;/a&gt;):&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var oldDocumentWrite = document.write

// change document.write temporary
document.write = function(node){
    $("body").append(node)
}

// get script
$.getScript( "http://www.googleadservices.com/pagead/conversion.js", function() {
    // replace the temp document.write with the original version
    setTimeout(function() {
        document.write = oldDocumentWrite
    }, 100)
});
&lt;/pre&gt;
&lt;p&gt;This threw up some red flags for me - why are we hijacking &lt;code&gt;document.write&lt;/code&gt;? If we have to do this weird dance to get around the problem, maybe it&amp;#39;s as unsafe as Chrome would have us believe - should we do something safer?&lt;/p&gt;

&lt;p&gt;Time to do some more Googling...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Fix two (good)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The correct way to deal with this problem is to use Google Adwords async script. I know it seems really simple and obvious, but I did find a lot of people suggesting the first way, so I&amp;#39;m hoping this post is news to some of you.&lt;/p&gt;

&lt;p&gt;Here&amp;#39;s how to use Google&amp;#39;s async code:&lt;/p&gt;

&lt;p&gt;On your main page (not anything that&amp;#39;s loaded asynchronously) link to the async conversion file.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&amp;lt;script type="text/javascript" src="//www.googleadservices.com/pagead/conversion_async.js" charset="utf-8"&amp;gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;
&lt;p&gt;This way the &lt;code&gt;google_trackConversion&lt;/code&gt; method is written on document load, and not async which caused the original warning we saw.&lt;/p&gt;

&lt;p&gt;Then wherever your async call returns you can trigger a call to track the conversion:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;&amp;lt;script type="text/javascript"&amp;gt;
/* &amp;lt;![CDATA[ */
window.google_trackConversion({
  google_conversion_id: 123456789,
  google_conversion_label: "your label here",
  google_custom_params: {
    parameter1: 'abc123',
    parameter2: 29.99
  }
});
//]]&amp;gt;
&amp;lt;/script&amp;gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;References&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/adwords-remarketing-tag/asynchronous/"&gt;Docs&lt;/a&gt; for the good fix&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/a/25240908/863846"&gt;Stack overflow answer&lt;/a&gt; for the good fix&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.jakobbeyer.de/asynchronous-google-adwords-conversion-tracking"&gt;Bad fix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: feature detection vs. inference vs. UA string</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/feature-detection-vs-inference/"/>
    <id>http://lucybain.com/blog/2014/feature-detection-vs-inference/</id>
    <published>2014-12-04T00:00:00Z</published>
    <updated>2014-12-08T22:16:33+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s the difference between feature detection, feature inference, and using the UA string?&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s start smaller...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is feature detection?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When you check if a certain feature exists, that&amp;#39;s feature detection.&lt;/p&gt;

&lt;p&gt;We need to write code that checks if features exist in JS since different browsers have different implementations, something like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;var text;
if(typeof(Text) === "function"){
    text = new Text('Oh, how quick that fox was!');
} else {
    text = 'Oh, how quick that fox was!';
}
&lt;/pre&gt;
&lt;p&gt;That means you can be confident you&amp;#39;ve covered all of your bases with different browser implementations.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is feature inference?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When you make an assumption that because one feature is present (or not) another one will also be present (or not). (And you know what people say about when you assume something...)&lt;/p&gt;

&lt;p&gt;The general thought process goes like this:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Chrome implements the &lt;code&gt;Text&lt;/code&gt; function. I also know Chrome doesn&amp;#39;t have &lt;code&gt;applyElement&lt;/code&gt; like IE does. So I&amp;#39;ll write code like...&lt;/em&gt;&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;if(typeof applyElement != 'undefined') {
    // now I know I'm not in IE, I'll just assume Text is available
    text = new Text('Oh, how quick that fox was!');
}
&lt;/pre&gt;
&lt;p&gt;But oops! Someone looked at that code in Firefox which doesn&amp;#39;t implement &lt;code&gt;applyElement&lt;/code&gt; or &lt;code&gt;Text&lt;/code&gt;! They got an error :(&lt;/p&gt;

&lt;p&gt;So that&amp;#39;s the problem. Since you&amp;#39;re not checking for the feature you&amp;#39;re using you&amp;#39;re more likely to have inconsistencies. Also, if in the future one of the browsers changes what they implement all your assumptions will be inacurate.&lt;/p&gt;

&lt;p&gt;So yeah, it&amp;#39;s bad.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What is the UA string?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;quot;UA&amp;quot; stands for user agent, which means the browser (and a whole lot of other stuff). Mine looks like this:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71
&lt;/pre&gt;
&lt;p&gt;(You can find your user string at &lt;a href="http://whatsmyuseragent.com/"&gt;whatsmyuseragent.com&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;But you can see in there (at the end) it says what browser I&amp;#39;m on. So it would be possible to check for a specific version of Chrome by &amp;quot;sniffing&amp;quot; the user agent string. This is generally considered bad practice (but seems to be slightly better practice than feature inference).&lt;/p&gt;

&lt;p&gt;Just like with feature inference, if you use the UA string you&amp;#39;re making an assumption about how the string will be written, what changes are likely to happen in this particular version, and that your code will be able to handle any future changes.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;TL;DR&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Use feature detection if you&amp;#39;re working with a feature that isn&amp;#39;t available across all browsers. When the browsers upgrade your code will be able to take advantage of the upgrade and your code will still work.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.nczonline.net/blog/2009/12/29/feature-detection-is-not-browser-detection/"&gt;Feature detection is not browser detection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/a/20105161/863846"&gt;Stack overflow answer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Mozilla&amp;#39;s article on &lt;a href="https://developer.mozilla.org/en-US/docs/Browser_detection_using_the_user_agent"&gt;working with the user agent&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: &lt;code&gt;.call&lt;/code&gt; vs. &lt;code&gt;.apply&lt;/code&gt;</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/call-vs-apply/"/>
    <id>http://lucybain.com/blog/2014/call-vs-apply/</id>
    <published>2014-11-30T00:00:00Z</published>
    <updated>2014-11-30T15:55:37+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What&amp;#39;s the difference between &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt;?&lt;/h2&gt;

&lt;p&gt;Let&amp;#39;s start with the similarities.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What are &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Both methods allow you to invoke a function and pass parameters through.&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function printer(message) {
    console.log(message)
}

printer.call("hello") // logs "hello"
printer.apply("world!") // logs "world!"
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Wow. Awesome. A more verbose way to invoke functions. Fantastic. Why not just use &lt;code&gt;printer(&amp;quot;hello&amp;quot;)&lt;/code&gt;?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Well actually, &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt; can do more than simply invoke a method, they can also pass through &lt;strong&gt;context&lt;/strong&gt;. Here&amp;#39;s an example:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function Person(name){
    this.name = name;
    this.introduceSelf = function() {
        console.log("Hello, my name is " + this.name);
    }
}

var alice = new Person('Alice');
alice.introduceSelf();
// logs "Hello, my name is Alice", as expected

alice.introduceSelf.call({name: "Bob"});
// logs "Hello, my name is Bob"

alice.introduceSelf.apply({name: "Casey"});
// logs "Hello, my name is Casey"
&lt;/pre&gt;
&lt;p&gt;So &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt; allow you to manipulate the &lt;code&gt;this&lt;/code&gt; keyword for the invoked function.&lt;/p&gt;

&lt;p&gt;On to the main question...&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What&amp;#39;s the difference between &lt;code&gt;.call&lt;/code&gt; and &lt;code&gt;.apply&lt;/code&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It&amp;#39;s all about the way you pass parameters. That&amp;#39;s it. Let&amp;#39;s make our previous example more complex:&lt;/p&gt;
&lt;pre class="highlight plaintext"&gt;function Person(name){
    this.name = name;
    this.introduceSelf = function(greeting) {
        console.log(greeting + ", my name is " + this.name);
    }
}

var alice = new Person('Alice');
alice.introduceSelf('Hello');
// logs "Hello, my name is Alice", as expected

alice.introduceSelf.call({name: "Bob"}, 'Bonjour');
// logs "Bonjour, my name is Bob"

alice.introduceSelf.apply({name: "Casey"}, ['Hola']);
// logs "Hola, my name is Casey"
&lt;/pre&gt;
&lt;p&gt;For &lt;code&gt;.call&lt;/code&gt; you pass the parameters comma separated (like normal). For &lt;code&gt;.apply&lt;/code&gt; you pass the parameters in an array.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Why would you even bother having these two ways? Why not standardise?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;That&amp;#39;s a fair question. But the two methods have different use cases. If you know exactly how many arguments you&amp;#39;re passing, you should use &lt;code&gt;.call&lt;/code&gt;. If you don&amp;#39;t know, or if your arguments are already in an array, you should use &lt;code&gt;.apply&lt;/code&gt;. (Rephrased from a helpful &lt;a href="http://stackoverflow.com/a/1987244/863846"&gt;stackoverflow answer&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Ok, how am I going to remember this?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Turns out the folks on stackoverflow have some thoughts on that one too. Here&amp;#39;s how I&amp;#39;ll be remembering it:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;a&lt;/strong&gt;pply uses &lt;strong&gt;a&lt;/strong&gt;n &lt;strong&gt;a&lt;/strong&gt;rray&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;c&lt;/strong&gt;all &lt;strong&gt;c&lt;/strong&gt;ounts with &lt;strong&gt;c&lt;/strong&gt;ommas&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/1986896/what-is-the-difference-between-call-and-apply"&gt;stackoverflow question&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://odetocode.com/blogs/scott/archive/2007/07/04/function-apply-and-function-call-in-javascript.aspx"&gt;Scott Allen&amp;#39;s post&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content>
  </entry>
  <entry>
    <title>JS: ways to create objects</title>
    <link rel="alternate" href="http://lucybain.com/blog/2014/ways-to-create-objects/"/>
    <id>http://lucybain.com/blog/2014/ways-to-create-objects/</id>
    <published>2014-11-26T00:00:00Z</published>
    <updated>2014-11-26T22:11:30+11:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;h2&gt;What are a few different ways to create new objects?&lt;/h2&gt;

&lt;p&gt;Well it turns out this topic has been covered quite a lot (unlike my last post about host vs. native objects). I don&amp;#39;t really have anything to add to the conversation, so I&amp;#39;ll just give you the two links that I found the most helpful on this topic.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Resources&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.phpied.com/3-ways-to-define-a-javascript-class/"&gt;phpied&lt;/a&gt; - an attractive explanation. I found this easiest to read.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://a-developer-life.blogspot.com.au/2011/11/7-ways-to-create-objects-in-javascript.html"&gt;A Developer Life&lt;/a&gt; - an exhaustive list of ways to create objects, complete with examples. This was more in depth.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I hope you find those sites as useful as I did!&lt;/p&gt;
</content>
  </entry>
</feed>
